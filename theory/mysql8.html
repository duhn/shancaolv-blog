<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>MySQL8 | 文档</title>
    <meta name="generator" content="VuePress 1.9.9">
    
    <meta name="description" content="文档描述">
    
    <link rel="preload" href="/shancaolv-blog/assets/css/0.styles.d5c3beac.css" as="style"><link rel="preload" href="/shancaolv-blog/assets/js/app.d9fe4499.js" as="script"><link rel="preload" href="/shancaolv-blog/assets/js/3.c1ecc667.js" as="script"><link rel="preload" href="/shancaolv-blog/assets/js/1.6b777cdb.js" as="script"><link rel="preload" href="/shancaolv-blog/assets/js/7.d18fb729.js" as="script"><link rel="prefetch" href="/shancaolv-blog/assets/js/10.298b8386.js"><link rel="prefetch" href="/shancaolv-blog/assets/js/11.17c2e540.js"><link rel="prefetch" href="/shancaolv-blog/assets/js/12.39fb974a.js"><link rel="prefetch" href="/shancaolv-blog/assets/js/13.bcc90e37.js"><link rel="prefetch" href="/shancaolv-blog/assets/js/14.705de672.js"><link rel="prefetch" href="/shancaolv-blog/assets/js/15.ce73470a.js"><link rel="prefetch" href="/shancaolv-blog/assets/js/16.fc495b40.js"><link rel="prefetch" href="/shancaolv-blog/assets/js/17.535d96f3.js"><link rel="prefetch" href="/shancaolv-blog/assets/js/18.e9b52426.js"><link rel="prefetch" href="/shancaolv-blog/assets/js/19.72634062.js"><link rel="prefetch" href="/shancaolv-blog/assets/js/20.291a1839.js"><link rel="prefetch" href="/shancaolv-blog/assets/js/21.0fd7b4e2.js"><link rel="prefetch" href="/shancaolv-blog/assets/js/22.6c559402.js"><link rel="prefetch" href="/shancaolv-blog/assets/js/23.f81cb988.js"><link rel="prefetch" href="/shancaolv-blog/assets/js/24.3839ee9d.js"><link rel="prefetch" href="/shancaolv-blog/assets/js/25.f8181c87.js"><link rel="prefetch" href="/shancaolv-blog/assets/js/26.9ac6bc28.js"><link rel="prefetch" href="/shancaolv-blog/assets/js/27.2c63fb0f.js"><link rel="prefetch" href="/shancaolv-blog/assets/js/28.1142203c.js"><link rel="prefetch" href="/shancaolv-blog/assets/js/29.776c309d.js"><link rel="prefetch" href="/shancaolv-blog/assets/js/4.2d0ab2d6.js"><link rel="prefetch" href="/shancaolv-blog/assets/js/5.47a3ebbb.js"><link rel="prefetch" href="/shancaolv-blog/assets/js/6.0ff53a76.js"><link rel="prefetch" href="/shancaolv-blog/assets/js/8.07ec004d.js"><link rel="prefetch" href="/shancaolv-blog/assets/js/9.ac47dbea.js">
    <link rel="stylesheet" href="/shancaolv-blog/assets/css/0.styles.d5c3beac.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-7dd95ae2><div data-v-7dd95ae2><div class="password-shadow password-wrapper-out" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>文档</h3> <p class="description" data-v-59e6cb88>文档描述</p> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><!---->
          
        <!---->
        2023
      </a></span></div></div> <div class="hide" data-v-7dd95ae2><header class="navbar" data-v-7dd95ae2><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/shancaolv-blog/" class="home-link router-link-active"><!----> <span class="site-name">文档</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/shancaolv-blog/" class="nav-link"><i class="undefined"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      shanCaoLv 的工作博客
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/duhn" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-7dd95ae2></div> <aside class="sidebar" data-v-7dd95ae2><div class="personal-info-wrapper" data-v-1fad0c41 data-v-7dd95ae2><!----> <!----> <div class="num" data-v-1fad0c41><div data-v-1fad0c41><h3 data-v-1fad0c41>16</h3> <h6 data-v-1fad0c41>文章</h6></div> <div data-v-1fad0c41><h3 data-v-1fad0c41>0</h3> <h6 data-v-1fad0c41>标签</h6></div></div> <ul class="social-links" data-v-1fad0c41></ul> <hr data-v-1fad0c41></div> <nav class="nav-links"><div class="nav-item"><a href="/shancaolv-blog/" class="nav-link"><i class="undefined"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      shanCaoLv 的工作博客
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/duhn" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav> <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><a href="/shancaolv-blog/" class="sidebar-heading clickable router-link-active open"><span>欢迎学习</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/shancaolv-blog/" aria-current="page" class="sidebar-link">学前必读</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/shancaolv-blog/theory/plan" class="sidebar-heading clickable"><span>理论学习</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/shancaolv-blog/theory/plan.html" class="sidebar-link">计划 </a></li><li><section class="sidebar-group is-sub-group depth-1"><a href="/shancaolv-blog/theory/dataStructure/array" class="sidebar-heading clickable"><span>数据结构 </span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/shancaolv-blog/theory/dataStructure/array.html" class="sidebar-link">数组 </a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><a href="/shancaolv-blog/theory/mysql0" class="sidebar-heading clickable open"><span>MySQL </span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/shancaolv-blog/theory/mysql0.html" class="sidebar-link">mysql0 </a></li><li><a href="/shancaolv-blog/theory/mysql1.html" class="sidebar-link">mysql1 </a></li><li><a href="/shancaolv-blog/theory/mysql2.html" class="sidebar-link">mysql2 </a></li><li><a href="/shancaolv-blog/theory/mysql3.html" class="sidebar-link">mysql3 </a></li><li><a href="/shancaolv-blog/theory/mysql4.html" class="sidebar-link">mysql4 </a></li><li><a href="/shancaolv-blog/theory/mysql5.html" class="sidebar-link">mysql5 </a></li><li><a href="/shancaolv-blog/theory/mysql6.html" class="sidebar-link">mysql6 </a></li><li><a href="/shancaolv-blog/theory/mysql7.html" class="sidebar-link">mysql7 </a></li><li><a href="/shancaolv-blog/theory/mysql8.html" aria-current="page" class="active sidebar-link">mysql8 </a></li><li><a href="/shancaolv-blog/theory/mysql9.html" class="sidebar-link">mysql9 </a></li></ul></section></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/shancaolv-blog/practice/plan" class="sidebar-heading clickable"><span>代码实现</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/shancaolv-blog/practice/plan.html" class="sidebar-link">计划 </a></li><li><section class="sidebar-group is-sub-group depth-1"><a href="/shancaolv-blog/practice/dataStructure/array" class="sidebar-heading clickable"><span>数据结构 </span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/shancaolv-blog/practice/dataStructure/array.html" class="sidebar-link">数组 </a></li></ul></section></li></ul></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>MySQL8</h3> <!----> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><!---->
          
        <!---->
        2023
      </a></span></div></div> <div data-v-7dd95ae2><div data-v-7dd95ae2><main class="page" style="padding-right:0;"><section style="display:;"><div class="page-title"><h1 class="title">MySQL8</h1> <div data-v-8a445198><i class="iconfont reco-account" data-v-8a445198><span data-v-8a445198>shanCaoLv</span></i> <i class="iconfont reco-date" data-v-8a445198><span data-v-8a445198>2023/5/25</span></i> <!----> <!----></div></div> <div class="theme-reco-content content__default"><h3 id="关键词"><a href="#关键词" class="header-anchor">#</a> 关键词</h3> <h1 id="_08-事务到底是隔离的还是不隔离的"><a href="#_08-事务到底是隔离的还是不隔离的" class="header-anchor">#</a> 08_事务到底是隔离的还是不隔离的</h1> <blockquote><p>你好，我是林晓斌。 你现在看到的这篇文章是我重写过的。在第一版文章发布之后，我发现在介绍事务可见性规则时，由于引入了太多概念，导致理解起来很困难。随后，我索性就重写了这篇文章。 现在的用户留言中，还能看到第一版文章中引入的 up_limit_id 的概念，为了避免大家产生误解，再此特地和大家事先说明一下。</p></blockquote> <p>我在第 3 篇文章和你讲事务隔离级别的时候提到过，如果是可重复读隔离级别，事务 T 启动的时候会创建一个视图 read-view，之后事务 T 执行期间，即使有其他事务修改了数据，事务 T 看到的仍然跟在启动时看到的一样。也就是说，一个在可重复读隔离级别下执行的事务，好像与世无争，不受外界影响。</p> <p>但是，我在上一篇文章中，和你分享行锁的时候又提到，一个事务要更新一行，如果刚好有另外一个事务拥有这一行的行锁，它又不能这么超然了，会被锁住，进入等待状态。问题是，既然进入了等待状态，那么等到这个事务自己获取到行锁要更新数据的时候，它读到的值又是什么呢？</p> <p>我给你举一个例子吧。下面是一个只有两行的表的初始化语句。</p> <div class="language-sql extra-class"><pre class="language-sql"><code>mysql<span class="token operator">&gt;</span> <span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>t<span class="token punctuation">`</span></span> <span class="token punctuation">(</span>
  <span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">`</span>k<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">)</span>
<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span><span class="token punctuation">;</span>
<span class="token keyword">insert</span> <span class="token keyword">into</span> t<span class="token punctuation">(</span>id<span class="token punctuation">,</span> k<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><img src="/shancaolv-blog/assets/img/823acf76e53c0bdba7beab45e72e90d6.a97be126.png" alt="img"></p> <p>图 1 事务 A、B、C 的执行流程</p> <p>这里，我们需要注意的是事务的启动时机。</p> <p>begin/start transaction 命令并不是一个事务的起点，在执行到它们之后的第一个操作 InnoDB 表的语句，事务才真正启动。如果你想要马上启动一个事务，可以使用 start transaction with consistent snapshot 这个命令。</p> <blockquote><p>第一种启动方式，一致性视图是在第执行第一个快照读语句时创建的； 第二种启动方式，一致性视图是在执行 start transaction with consistent snapshot 时创建的。</p></blockquote> <p>还需要注意的是，在整个专栏里面，我们的例子中如果没有特别说明，都是默认 autocommit=1。</p> <p>在这个例子中，事务 C 没有显式地使用 begin/commit，表示这个 update 语句本身就是一个事务，语句完成的时候会自动提交。事务 B 在更新了行之后查询 ; 事务 A 在一个只读事务中查询，并且时间顺序上是在事务 B 的查询之后。</p> <p>这时，如果我告诉你事务 B 查到的 k 的值是 3，而事务 A 查到的 k 的值是 1，你是不是感觉有点晕呢？</p> <p>所以，今天这篇文章，我其实就是想和你说明白这个问题，希望借由把这个疑惑解开的过程，能够帮助你对 InnoDB 的事务和锁有更进一步的理解。</p> <p>在 MySQL 里，有两个“视图”的概念：</p> <ul><li>一个是 view。它是一个用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果。创建视图的语法是 create view … ，而它的查询方法与表一样。</li> <li>另一个是 InnoDB 在实现 MVCC 时用到的一致性读视图，即 consistent read view，用于支持 RC（Read Committed，读提交）和 RR（Repeatable Read，可重复读）隔离级别的实现。</li></ul> <p>它没有物理结构，作用是事务执行期间用来定义“我能看到什么数据”。</p> <p>在第 3 篇文章[《事务隔离：为什么你改了我还看不见？》]中，我跟你解释过一遍 MVCC 的实现逻辑。今天为了说明查询和更新的区别，我换一个方式来说明，把 read view 拆开。你可以结合这两篇文章的说明来更深一步地理解 MVCC。</p> <h2 id="快照-在-mvcc-里是怎么工作的"><a href="#快照-在-mvcc-里是怎么工作的" class="header-anchor">#</a> “快照”在 MVCC 里是怎么工作的？</h2> <p>在可重复读隔离级别下，事务在启动的时候就“拍了个快照”。注意，这个快照是基于整库的。</p> <p>这时，你会说这看上去不太现实啊。如果一个库有 100G，那么我启动一个事务，MySQL 就要拷贝 100G 的数据出来，这个过程得多慢啊。可是，我平时的事务执行起来很快啊。</p> <p>实际上，我们并不需要拷贝出这 100G 的数据。我们先来看看这个快照是怎么实现的。</p> <p>InnoDB 里面每个事务有一个唯一的事务 ID，叫作 transaction id。它是在事务开始的时候向 InnoDB 的事务系统申请的，是按申请顺序严格递增的。</p> <p>而每行数据也都是有多个版本的。每次事务更新数据的时候，都会生成一个新的数据版本，并且把 transaction id 赋值给这个数据版本的事务 ID，记为 row trx_id。同时，旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它。</p> <p>也就是说，数据表中的一行记录，其实可能有多个版本 (row)，每个版本有自己的 row trx_id。</p> <p>如图 2 所示，就是一个记录被多个事务连续更新后的状态。</p> <p><img src="/shancaolv-blog/assets/img/68d08d277a6f7926a41cc5541d3dfced.5790648c.png" alt="img"></p> <p>图 2 行状态变更图</p> <p>图中虚线框里是同一行数据的 4 个版本，当前最新版本是 V4，k 的值是 22，它是被 transaction id 为 25 的事务更新的，因此它的 row trx_id 也是 25。</p> <p>你可能会问，前面的文章不是说，语句更新会生成 undo log（回滚日志）吗？那么，<strong>undo log 在哪呢？</strong></p> <p>实际上，图 2 中的三个虚线箭头，就是 undo log；而 V1、V2、V3 并不是物理上真实存在的，而是每次需要的时候根据当前版本和 undo log 计算出来的。比如，需要 V2 的时候，就是通过 V4 依次执行 U3、U2 算出来。</p> <p>明白了多版本和 row trx_id 的概念后，我们再来想一下，InnoDB 是怎么定义那个“100G”的快照的。</p> <p>按照可重复读的定义，一个事务启动的时候，能够看到所有已经提交的事务结果。但是之后，这个事务执行期间，其他事务的更新对它不可见。</p> <p>因此，一个事务只需要在启动的时候声明说，“以我启动的时刻为准，如果一个数据版本是在我启动之前生成的，就认；如果是我启动以后才生成的，我就不认，我必须要找到它的上一个版本”。</p> <p>当然，如果“上一个版本”也不可见，那就得继续往前找。还有，如果是这个事务自己更新的数据，它自己还是要认的。</p> <p>在实现上， InnoDB 为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务 ID。“活跃”指的就是，启动了但还没提交。</p> <p>数组里面事务 ID 的最小值记为低水位，当前系统里面已经创建过的事务 ID 的最大值加 1 记为高水位。</p> <p>这个视图数组和高水位，就组成了当前事务的一致性视图（read-view）。</p> <p>而数据版本的可见性规则，就是基于数据的 row trx_id 和这个一致性视图的对比结果得到的。</p> <p>这个视图数组把所有的 row trx_id 分成了几种不同的情况。</p> <p><img src="/shancaolv-blog/assets/img/882114aaf55861832b4270d44507695e.8e082b11.png" alt="img"></p> <p>图 3 数据版本可见性规则</p> <p>这样，对于当前事务的启动瞬间来说，一个数据版本的 row trx_id，有以下几种可能：</p> <ol><li>如果落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的；</li> <li>如果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的；</li> <li>如果落在黄色部分，那就包括两种情况 a. 若 row trx_id 在数组中，表示这个版本是由还没提交的事务生成的，不可见； b. 若 row trx_id 不在数组中，表示这个版本是已经提交了的事务生成的，可见。</li></ol> <p>比如，对于图 2 中的数据来说，如果有一个事务，它的低水位是 18，那么当它访问这一行数据时，就会从 V4 通过 U3 计算出 V3，所以在它看来，这一行的值是 11。</p> <p>你看，有了这个声明后，系统里面随后发生的更新，是不是就跟这个事务看到的内容无关了呢？因为之后的更新，生成的版本一定属于上面的 2 或者 3(a) 的情况，而对它来说，这些新的数据版本是不存在的，所以这个事务的快照，就是“静态”的了。</p> <p>所以你现在知道了，<strong>InnoDB 利用了“所有数据都有多个版本”的这个特性，实现了“秒级创建快照”的能力。</strong></p> <p>接下来，我们继续看一下图 1 中的三个事务，分析下事务 A 的语句返回的结果，为什么是 k=1。</p> <p>这里，我们不妨做如下假设：</p> <ol><li>事务 A 开始前，系统里面只有一个活跃事务 ID 是 99；</li> <li>事务 A、B、C 的版本号分别是 100、101、102，且当前系统里只有这四个事务；</li> <li>三个事务开始前，(1,1）这一行数据的 row trx_id 是 90。</li></ol> <p>这样，事务 A 的视图数组就是 [99,100], 事务 B 的视图数组是 [99,100,101], 事务 C 的视图数组是 [99,100,101,102]。</p> <p>为了简化分析，我先把其他干扰语句去掉，只画出跟事务 A 查询逻辑有关的操作：</p> <p><img src="/shancaolv-blog/assets/img/9416c310e406519b7460437cb0c5c149.f57f7bf4.png" alt="img"></p> <p>图 4 事务 A 查询数据逻辑图</p> <p>从图中可以看到，第一个有效更新是事务 C，把数据从 (1,1) 改成了 (1,2)。这时候，这个数据的最新版本的 row trx_id 是 102，而 90 这个版本已经成为了历史版本。</p> <p>第二个有效更新是事务 B，把数据从 (1,2) 改成了 (1,3)。这时候，这个数据的最新版本（即 row trx_id）是 101，而 102 又成为了历史版本。</p> <p>你可能注意到了，在事务 A 查询的时候，其实事务 B 还没有提交，但是它生成的 (1,3) 这个版本已经变成当前版本了。但这个版本对事务 A 必须是不可见的，否则就变成脏读了。</p> <p>好，现在事务 A 要来读数据了，它的视图数组是 [99,100]。当然了，读数据都是从当前版本读起的。所以，事务 A 查询语句的读数据流程是这样的：</p> <ul><li>找到 (1,3) 的时候，判断出 row trx_id=101，比高水位大，处于红色区域，不可见；</li> <li>接着，找到上一个历史版本，一看 row trx_id=102，比高水位大，处于红色区域，不可见；</li> <li>再往前找，终于找到了（1,1)，它的 row trx_id=90，比低水位小，处于绿色区域，可见。</li></ul> <p>这样执行下来，虽然期间这一行数据被修改过，但是事务 A 不论在什么时候查询，看到这行数据的结果都是一致的，所以我们称之为一致性读。</p> <p>这个判断规则是从代码逻辑直接转译过来的，但是正如你所见，用于人肉分析可见性很麻烦。</p> <p>所以，我来给你翻译一下。一个数据版本，对于一个事务视图来说，除了自己的更新总是可见以外，有三种情况：</p> <ol><li>版本未提交，不可见；</li> <li>版本已提交，但是是在视图创建后提交的，不可见；</li> <li>版本已提交，而且是在视图创建前提交的，可见。</li></ol> <p>现在，我们用这个规则来判断图 4 中的查询结果，事务 A 的查询语句的视图数组是在事务 A 启动的时候生成的，这时候：</p> <ul><li>(1,3) 还没提交，属于情况 1，不可见；</li> <li>(1,2) 虽然提交了，但是是在视图数组创建之后提交的，属于情况 2，不可见；</li> <li>(1,1) 是在视图数组创建之前提交的，可见。</li></ul> <p>你看，去掉数字对比后，只用时间先后顺序来判断，分析起来是不是轻松多了。所以，后面我们就都用这个规则来分析。</p> <h2 id="更新逻辑"><a href="#更新逻辑" class="header-anchor">#</a> 更新逻辑</h2> <p>细心的同学可能有疑问了：<strong>事务 B 的 update 语句，如果按照一致性读，好像结果不对哦？</strong></p> <p>你看图 5 中，事务 B 的视图数组是先生成的，之后事务 C 才提交，不是应该看不见 (1,2) 吗，怎么能算出 (1,3) 来？</p> <p><img src="/shancaolv-blog/assets/img/86ad7e8abe7bf16505b97718d8ac149f.036bce89.png" alt="img"></p> <p>图 5 事务 B 更新逻辑图</p> <p>是的，如果事务 B 在更新之前查询一次数据，这个查询返回的 k 的值确实是 1。</p> <p>但是，当它要去更新数据的时候，就不能再在历史版本上更新了，否则事务 C 的更新就丢失了。因此，事务 B 此时的 set k=k+1 是在（1,2）的基础上进行的操作。</p> <p>所以，这里就用到了这样一条规则：<strong>更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”（current read）。</strong></p> <p>因此，在更新的时候，当前读拿到的数据是 (1,2)，更新后生成了新版本的数据 (1,3)，这个新版本的 row trx_id 是 101。</p> <p>所以，在执行事务 B 查询语句的时候，一看自己的版本号是 101，最新数据的版本号也是 101，是自己的更新，可以直接使用，所以查询得到的 k 的值是 3。</p> <p>这里我们提到了一个概念，叫作当前读。其实，除了 update 语句外，select 语句如果加锁，也是当前读。</p> <p>所以，如果把事务 A 的查询语句 select * from t where id=1 修改一下，加上 lock in share mode 或 for update，也都可以读到版本号是 101 的数据，返回的 k 的值是 3。下面这两个 select 语句，就是分别加了读锁（S 锁，共享锁）和写锁（X 锁，排他锁）。</p> <div class="language-csharp extra-class"><pre class="language-csharp"><code>mysql<span class="token operator">&gt;</span> <span class="token keyword">select</span> k <span class="token keyword">from</span> t <span class="token keyword">where</span> <span class="token class-name">id</span><span class="token operator">=</span><span class="token number">1</span> <span class="token keyword">lock</span> <span class="token keyword">in</span> <span class="token class-name">share</span> mode<span class="token punctuation">;</span>
mysql<span class="token operator">&gt;</span> <span class="token keyword">select</span> k <span class="token keyword">from</span> t <span class="token keyword">where</span> <span class="token class-name">id</span><span class="token operator">=</span><span class="token number">1</span> <span class="token keyword">for</span> update<span class="token punctuation">;</span>
</code></pre></div><p>再往前一步，假设事务 C 不是马上提交的，而是变成了下面的事务 C’，会怎么样呢？</p> <p><img src="/shancaolv-blog/assets/img/cda2a0d7decb61e59dddc83ac51efb6e.bbb0411c.png" alt="img"></p> <p>图 6 事务 A、B、C'的执行流程</p> <p>事务 C’的不同是，更新后并没有马上提交，在它提交前，事务 B 的更新语句先发起了。前面说过了，虽然事务 C’还没提交，但是 (1,2) 这个版本也已经生成了，并且是当前的最新版本。那么，事务 B 的更新语句会怎么处理呢？</p> <p>这时候，我们在上一篇文章中提到的“两阶段锁协议”就要上场了。事务 C’没提交，也就是说 (1,2) 这个版本上的写锁还没释放。而事务 B 是当前读，必须要读最新版本，而且必须加锁，因此就被锁住了，必须等到事务 C’释放这个锁，才能继续它的当前读。</p> <p><img src="/shancaolv-blog/assets/img/540967ea905e8b63630e496786d84c92.51afeb14.png" alt="img"></p> <p>图 7 事务 B 更新逻辑图（配合事务 C'）</p> <p>到这里，我们把一致性读、当前读和行锁就串起来了。</p> <p>现在，我们再回到文章开头的问题：<strong>事务的可重复读的能力是怎么实现的？</strong></p> <p>可重复读的核心就是一致性读（consistent read）；而事务更新数据的时候，只能用当前读。如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。</p> <p>而读提交的逻辑和可重复读的逻辑类似，它们最主要的区别是：</p> <ul><li>在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图；</li> <li>在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图。</li></ul> <p>那么，我们再看一下，在读提交隔离级别下，事务 A 和事务 B 的查询语句查到的 k，分别应该是多少呢？</p> <p>这里需要说明一下，“start transaction with consistent snapshot; ”的意思是从这个语句开始，创建一个持续整个事务的一致性快照。所以，在读提交隔离级别下，这个用法就没意义了，等效于普通的 start transaction。</p> <p>下面是读提交时的状态图，可以看到这两个查询语句的创建视图数组的时机发生了变化，就是图中的 read view 框。（注意：这里，我们用的还是事务 C 的逻辑直接提交，而不是事务 C’）</p> <p><img src="/shancaolv-blog/assets/img/18fd5179b38c8c3804b313c3582cd1be.c9421cdb.jpg" alt="img"></p> <p>图 8 读提交隔离级别下的事务状态图</p> <p>这时，事务 A 的查询语句的视图数组是在执行这个语句的时候创建的，时序上 (1,2)、(1,3) 的生成时间都在创建这个视图数组的时刻之前。但是，在这个时刻：</p> <ul><li>(1,3) 还没提交，属于情况 1，不可见；</li> <li>(1,2) 提交了，属于情况 3，可见。</li></ul> <p>所以，这时候事务 A 查询语句返回的是 k=2。</p> <p>显然地，事务 B 查询结果 k=3。</p> <h2 id="小结"><a href="#小结" class="header-anchor">#</a> 小结</h2> <p>InnoDB 的行数据有多个版本，每个数据版本有自己的 row trx_id，每个事务或者语句有自己的一致性视图。普通查询语句是一致性读，一致性读会根据 row trx_id 和一致性视图确定数据版本的可见性。</p> <ul><li>对于可重复读，查询只承认在事务启动前就已经提交完成的数据；</li> <li>对于读提交，查询只承认在语句启动前就已经提交完成的数据；</li></ul> <p>而当前读，总是读取已经提交完成的最新版本。</p> <p>你也可以想一下，为什么表结构不支持“可重复读”？这是因为表结构没有对应的行数据，也没有 row trx_id，因此只能遵循当前读的逻辑。</p> <p>当然，MySQL 8.0 已经可以把表结构放在 InnoDB 字典里了，也许以后会支持表结构的可重复读。</p> <p>又到思考题时间了。我用下面的表结构和初始化语句作为试验环境，事务隔离级别是可重复读。现在，我要把所有“字段 c 和 id 值相等的行”的 c 值清零，但是却发现了一个“诡异”的、改不掉的情况。请你构造出这种情况，并说明其原理。</p> <div class="language-sql extra-class"><pre class="language-sql"><code>mysql<span class="token operator">&gt;</span> <span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>t<span class="token punctuation">`</span></span> <span class="token punctuation">(</span>
  <span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">`</span>c<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">)</span>
<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span><span class="token punctuation">;</span>
<span class="token keyword">insert</span> <span class="token keyword">into</span> t<span class="token punctuation">(</span>id<span class="token punctuation">,</span> c<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><img src="/shancaolv-blog/assets/img/9b8fe7cf88c9ba40dc12e93e36c3060b.39078069.png" alt="img">复现出来以后，请你再思考一下，在实际的业务开发中有没有可能碰到这种情况？你的应用代码会不会掉进这个“坑”里，你又是怎么解决的呢？</p> <p>你可以把你的思考和观点写在留言区里，我会在下一篇文章的末尾和你讨论这个问题。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。</p> <h2 id="上期问题时间"><a href="#上期问题时间" class="header-anchor">#</a> 上期问题时间</h2> <p>我在上一篇文章最后，留给你的问题是：怎么删除表的前 10000 行。比较多的留言都选择了第二种方式，即：在一个连接中循环执行 20 次 delete from T limit 500。</p> <p>确实是这样的，第二种方式是相对较好的。</p> <p>第一种方式（即：直接执行 delete from T limit 10000）里面，单个语句占用时间长，锁的时间也比较长；而且大事务还会导致主从延迟。</p> <p>第三种方式（即：在 20 个连接中同时执行 delete from T limit 500），会人为造成锁冲突。</p></div></section> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev"><a href="/shancaolv-blog/theory/mysql7.html" class="prev">
          mysql7 
        </a></span> <span class="next"><a href="/shancaolv-blog/theory/mysql9.html">
          mysql9 
        </a></span></p></div> <div class="comments-wrapper"><!----></div></main></div> <!----></div> <ul class="sub-sidebar sub-sidebar-wrapper" style="width:0;" data-v-b57cc07c data-v-7dd95ae2></ul></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div></div></div>
    <script src="/shancaolv-blog/assets/js/app.d9fe4499.js" defer></script><script src="/shancaolv-blog/assets/js/3.c1ecc667.js" defer></script><script src="/shancaolv-blog/assets/js/1.6b777cdb.js" defer></script><script src="/shancaolv-blog/assets/js/7.d18fb729.js" defer></script>
  </body>
</html>
